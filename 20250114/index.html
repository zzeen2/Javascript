<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    console.time(); // 여기서 부터 시간의 시작
    // 코드의 실행시간이 이 사이에 작성한 코드 내용
    let result = 0;
    for (let i; i<=100; i++) {
        result +=i;
    } 
    console.timeEnd(); // 여기서 시간 종료

    // coonsole.time();
    // let n = 100;
    // console.log((n/2)*(n + 1));
    // console.timeEnd();

    // console.time();

    // function sum(n, result){
    //     if (n === 100){
    //         return result;
    //     }
    //     return sum(n+1,reult + n);
    // }
    // console.log(sum(1,0));
    // console.timeEnd();

    // console.time();
    // function fibo(n){
    //     if (n===1 || n===2) return 1;
    //     return fibo (n-1) + fibo(n-2);
    // }
    // console.log(fibo(100));
    // console.timeEnd();
    // 재귀 함수가 콜스택이 많이 쌓여서 실행이 많아져서 
    // 메모이제이션 기법 ***
    // 연산을 할 때 이미 했던 연산이라면 다시 연산을 하지 않고 결과를 저장해 놨다가 결과만 보여주면 끝
    // 메모이제이션 기법 사용 예)
    console.time();
    let memo = {}; // 연산의 내용을 저장할 객체=
    
    // 예약어 in 
    // 객체 안에 해당 키가 있는지 확인
    // [키 이름] in [객체]
    // true false > bool 타입의 반환값
    // 키의 유무에 따라 이미 했던 연산인지 판별해서 연산을 할지 이전에 저장한 값을 반환할지 
    
    function newFibo (n){
        let result; // 결과를 담을 변수

        // 상태 확인, 했던 연산인지
        if(n in memo){
            // 키값이 있다 > true 연산을 했었네
            result = memo[n];
        }else {
            // 연산했던 내용이 아니면 새로운 연산을 수행, 그 결과를 저장
            if (n === 1 || n === 2){
                result = 1;
            }else {
                result = newFibo(n-1)+newFibo(n-2);
            }
            //n의 키를 생성하고 값을 할당
            // 연산의 결과를 저장하는 것
            memo[n] = reuslt;
        }
        return result;
    }
    console.log(newFibo(100));
    console.timeEnd()
</script>
</html>