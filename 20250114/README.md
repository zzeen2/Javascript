# 생성자 함수, 재귀함수

## 재귀함수
> 재귀함수는 함수의 내용에서 다시 함수 이름으로 함수의 내용 안에서 실행되는 것이 반복되는 방식
> for 문으로 반복문으로 구현 가능한 로직들은 재귀함수로 대부분 작성이 가능하다.
> 재귀함수를 사용하는 이유는, 반복하는 내용의 기능을 여러개로 나눠서 직관적으로 관리할때
> 사용하는 프로그래밍 패턴중의 하나

 1 + 2 / 3 * 4 + 5
 > 재귀를 작성할 때 더이상 나눠야 할 필요가 없을 때가 종료시점
 > 문제를 나눠서 기능을 작성하는 경우 패턴을 찾아서 활용해야한다.

 ## 사용 예 

 ## 반복문을 사용해서 만든 로직

```js
// 1~100 더한 수
let result = 0

for (let i =1 i <=100 i ++) {
   result +=i
}
console.log(result)
// 100 까지 더한수

// 연산식을 사용한 예
 let n = 100;
conole.log((n/2) * (n+1));
//1~100까지 더한 수
// 알고리즘 풀면서 외우는 것

// 재귀함수를 사용한 예
function sum (n,reult) {
    if (n === 101){
        console.log(result);
        return n;
    }
    sum(n+1, result + n); // 재귀함수 
}
sum(1,0);
//> if 문의 조건을 만족할때까지 반복함 (n===101, result===100 까지)

function sum2(n, result) {
    if ( n ===101) {
        return result;
    }
    return sum(n+1, result + n);
}

console.log(sum2(1,0));
```
> 재귀함수는 잘 쓰지 못하면 그냥 반복문으로 돌리는 것보다 못하다. 최적화가 안좋다.

## 재귀 함수의 목적
> 장점으로 반복문을 많이 사용하는 경우보다 코드의 간결성과 직관성이 증가한다.
> 하지만 단점으로 스택에 함수의 실행이 많이 쌓여서 메모리의 공간이 많이 차지된다. 속도, 성능 저하

## 피보나치 수열
> 피보나치 수열은 토끼가 처음에 한쌍이 있고
> 한달이 지나면 한쌍의 토끼가 성장
> 그 이후 한달이 지나면 성장한 토끼가 새끼토끼 한쌍을 낳는다.
> 그 이후 한달이 또 지나면 성장한 토끼는 또 새끼 토끼 한쌍을 낳고, 이전달의 새끼 토끼 한쌍은 성장한다.
> 이런식으로 계슥 증가하는 수열
> 규칙: 토끼는 수명이 무한

```js
function fibo (n) {
    if (n===1 || n ===2) return 1; // 한쌍의 토끼
    return fibo (n - 1) + fibo(n - 2); // 토끼가 성장하고 한쌍의 새끼토끼를 낳는 값을 구하기 위해서.

}
```
> 수학 공식을 공부할건 아니니까 프로그래머스, 백준 풀면서 외우는 방식으로

### 자바스크립트의 실행 시간 복잡도를 한번 확인해보자.
> 코드의 실행이 얼마나 걸렸는지

// 계산기 구현할 때  => 사칙연산 처리할때

4 * 3 / 2 + 2 * 5 = 

## 생성자 함수
> 객체를 생성하기 위한 함수를 작성
> 객체를 생성의 목표를 가지고 있다.
> function 키워드를 사용해서 생성자 함수를 만드는데 이후에는 class 
> ES5 까지는 function 키워드로 객체의 생성자 함수를 만들었다.
> 만능 function 기능 작성과 객체의 생성과 여러가지로 사용을 하는 느낌
> ES6 부터 이러한 부분들이 바뀌는 키워드가 많이 추가되었다.

> 화살표 함수 (this 개념), class (객체 생성을 위해서만 만들어진 예약어), 메서드 축약형
```js
// 생성자 함수
// 하나의 인스턴스
// 공장에서 상품을 만드는 기계같은 느낌.
// 자동차 객체 하나 생성

// funtion 안의 this는 바인딩을 한다는 의미는 바로 위의 객체를 참조한다.
// function에서 this의 키워드는 동적으로 변한다.
// 함수를 호출한 위치에서 this를 바인딩한다.
// 코드상의 this를 작성한 영역에서 객체를 참조하는게 화살표 함수

function myCar(color, name) {
    this.color = color;
    this.name = name;

}

myCar("red", "GV60"); // this 바인딩이 일어나서 
// this가 바인딩 되는 객체는 전역에 코드를 작성했고
// 브라우저 환경에서 실행되는데 전역객체인 window 객체에 키와 값으로 할당된다.

// 이미 만들어지 상품 2개만 들고있는 것.
// 동적으로 생성할 수 없지.

const obj = {
    color : "red",
    name : "GV60"
}
const obj2 = {
    color : "black",
    name : "SUV"
}

// 생성자 함수 사용
// new 예약어 (메모리에 새로운 객체를 만들어서 할당한다 = 동적할당)
// [new 예약어] [생성자 함수 실행식]
const obj3 = new myCar("red", "black");
// return을 생성한 객체의 주소를 반환한다.

```

> 함수를 사용해서 계산기를 구현
> 값을 입력을 받고 다음 연산자를 입력받고 두번째 값을 입력받아서 결과를 출력 하는 것 까지

> 돈을 입력하면 잔돈 계산기 100원 짜리로는 몇개, 천원짜리로는 몇개, 만원짜리는 몇개



