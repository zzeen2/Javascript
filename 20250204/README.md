# 클로저, 1급객체

> 함수가 선언될때의 `어휘적 위치`를 기억하고 해당 환경의 변수 등을 접근할수 있는 함수
>부 함수가 외부 함수의 변수에 접근할 수 있는 기능
> 자바스크립트에서 클로저의 개념이 가능한 이유 function 자바스크립트의 함수는 1급 객체이기 때문이다.
>자바스크립트에서는 함수가 생성될 때 **해당 함수가 선언된 위치(스코프)**를 기억합니다. 즉, 내부 함수는 자신이 선언된 외부 함수의 변수를 참조할 수 있으며, 외부 함수가 종료된 이후에도 여전히 접근할 수 있습니다.
> 함수형 프로그래밍을 할 수 있게 지원한다. ( 자바스크립트, 스위프트, 파이썬 ..)

```js
const a = if(1 ===1) {return true} // 이렇게 사용 불가. 2~3급
const b = function () {return 1} // 이렇게 사용 가능(제약 없음). 1급 객체

const time = (time, text) => {
    let a = 1;
    setTimeout(() = > {
        console.log(a);
        console.log(text);
    }, time)

    const foo = () => {
        a ++ ;
        console.log(a)
    }
    return foo
}
const foo2 = time() // 함수의 값을 할당
foo2(); //> 2 
foo2(); //> 3 왜 2 가 아니지? a가 초기화되지않고(해제되지않고) 참조되고있기 때문에 
foo2(); 
// 데이터의 은닉
// 함수 외부에서 참조해서 수정하는 내용을 방지할 수 있다. 

// c++ 포인터
// 포인터 주소의 개념을 배우지 못하는 이유가 js에서는 포인터의 개념이 없기때문에
```

## 클로저의 특징
1. 함수내에서 선언한 함수가 상위 스코프의 변수를 참조할 수 있다.
2. 함수의 실행이 종료되어도 참조하고 있는 스코프의 변수는 해제되지 않는다.

## 목적 
1. 데이터의 구조화(캡슐화) : 외부에서 값을 참조 혹은 수정할수 없게 할 수 있다. 
2. 함수형 프로그래밍 지원 : 함수 내부의 함수가 참조하는 변수를 가지고 반환받은 함수로 값을 참조할 수 있다.

### 1급객체 
> 프로그래밍에서 1급객체는 값처럼 사용할수 있는 제한이 없는 개체 
> 자바스크립트에서는 함수도 값이다.
- 변수처럼 자유롭게 사용할수있는 개체 ( 인자 전달 가능, 반환도 가능, 할당도 가능)
- c언어에서는 함수를 변수처럼 저장 불가능( 함수 포인터를 사용함 )
- 자바스크립트에서는 함수가 1급 객체이기 때문에 값으로 사용 가능
- 1급객체는 자유롭게 사용가능한 개체 2급과 3급은 사용에 제한이 있다.
- 1급 객체의 종류는 함수, 숫자, 문자열, 객체, 배열, 클래스, 프로미스 등 
- 1급 객체하는 이름으로 부르는 이유는 특권을 가졌다 라는 표현

### 1급 객체의 조건 내용
- 다른 함수의 매개변수로 전달해서 사용할 수 있다.
- 다른 함수의 return 반환값으로 사용할 수 있다.
- 변수 (배열 객체 등등)에 할당할 수 있는가?

> 자바스크립트의 함수는 1급 객체 

const a = (b) => {

}
{
    foo : a
} 
console.log(a);

a(() => {
    console.log(3)
})

### 클로저의 내용
> 자바스크립트의 클로저
> 함수안에 함수가 선언된 어휘적 렉시컬 환경
- **렉시컬 환경(Lexical Environment)**은 변수 및 함수 선언을 저장하고 관리하는 내부 객체입니다. 자바스크립트는 실행될 때 **각 실행 컨텍스트(Execution Context)**마다 렉시컬 환경을 생성하여 변수를 저장하고, 스코프 체인을 통해 접근합니다.
> 공식문서 클로저 `함수와 함수가 선언된 어휘적(렉시컬) 환경의 조합을 말한다. 이 환경은 클로저가 생성된 시점의 유효 범위 내에 있는 모든 지역 변수로 구성된다.`

## 문법
```js
const a = 0;
function b() {
    const index = 0;
    console.log(a);
    return function c() {
        console.log(index);
        function d() {
            let _b = 0;
            console.log(index);
        }
    }
    function e() {
        console.log(_b) // 렉시컬 스코프 체이닝 불가
    }
}

const d = b();
```

> 작성한 함수 위치가 어디냐? 내가 직접 함수의 코드를 작성한 위치가 어디냐에 따라 클로저가 될 수 있고 안될수도 있음

> 선언된 위치에서 상위 스코프를 참조한다. => 렉시컬 스코프
> 렉시컬 스코프 체인 => 선언된 위치에서 상위 스코프의 변수를 참조한다.

> js의 함수가 실행될 떄 실행 컨텍스트를 만들고 
> 콜스텍에 함수의 실행이 쌓이고 환경 레코드와 외부 아우터를 가지고 있다.
> 함수의 내부에서 함수가 선언되고, 내부함수에서 외부함수의 변수를 참조하는 경우
> js 함수가 호출되고 외부함수의 변수를 내부함수에서 참조하고 있는 경우 함수를 반환해서 사용하면 함수가 종료되어도 외부 함수의 변수의 값이 해제 되지 않는다.

### 렉시컬 환경
1. 렉시컬 임벨리먼트(Lexical Environment)
> 코드가 실행되는 컨텍스트

2. 환경 레코드
> 코드의 this 값과 선언된 변수와 함수를 기록하는 공간
> 코드의 평가 단계. 식별자의 바인딩을 기록하는 곳.

3. 외부 환경 참조(아우터)
> 렉시컬 환경에서 외부 렉시컬 환경을 참조
> 한단계 위의 상위 스코프를 참조한다.

### 렉시컬 스코프 
> 식별자의 스코프가 연결된 것을 스코프 체인이라고 한다.
> 코드를 작성한 구문이 작성한 그대로 스코프를 갖는 특징을 렉시컬 스코프라고 한다.
> 어휘적 스코프, 어휘적 스코프 체인


### 클로저 함수와 클로저 함수가 아닌 것
```js
// 클로저 함수 
function counter(){
    let index = 0;

    return function increment (){
        index ++;
        console.log(index);
    }
}
debugger
const increment = counter(); // return된 함수 increment 저장
debugger
increment ();//> 1
debugger
increment (); //> 2
// 스코프의 내용을 확인하면 클로저 스코프가 추가된 것을 확인할 수 있다. 그러면 클로저 함수

// 클로저 함수가 아닌 경우. 어휘적 위치에 내부 함수가 참조하는 외부함수의 변수가 없다.
function counter (){
    let index;
    index ++;
    console.log(index);
}
const increment = counter;
const increment2 = counter();

// 클로저 함수가 아닌 경우 2
// 내부함수가 전역변수를 참조하고 있고 외부 함수의 변수를 참조하지 않은 경우
let index = 0;
function counter(){
    return function increment(){
        index ++;
        console.log(index);
    }
}

const increment = counter();
increment();

// 클로저가 있음 
// 매개변수를 내부함수가 참조하고 있다.
function counter(index){
    return function increment()P{
        index ++;
        console.log(index);
    }
}
debugger
const increment = counter();
debugger
incrememt(1);
debugger


function foo(){
    let a = 1; // 이 값은 외부에서 참조할수 없는 값
    let b = 2;
    return function increment (){
        // 클로저 함수로만 접근이 가능하다.
        // 값의 은닉
        // 캡슐화
        a++; // a 라는 값을 참조할 수 있는 함수는 increment 클로저 함수 밖에 없다.
    }
}
function shop(){

}
// 상점의 변수는 클로저 함수로만 접근해서 변경할 수 있도록 
// 기능의 수정이 있을 경우 상점 함수의 내용만 수정하면 된다.
```

## 클로저의 목적(클로저는 모듈 패턴)
> js의 코도를 구조화 재사용 가능한 단위
> 함수형 프로그래밍으로 작업할수 있다.
> 불필요한 전역 변수를 만들 필요가 적어진다. 
> 재사용성도 높고 유지보수성
> 상태 관리의 캡슐화 ( 개인 변수 )

## 카운터 
```js
const createCounter = ()=>{
    let index = 0;

    const increment = ()=>{
        index ++;
        return index;
    }
    const decrement = ()=>{
        index --;
        return index;
    }
    return [increment, decrement]
    //return { increment, decrement} 객체로 내보내기
    //객체의 키를 할당하는 값을 참조하는 변수명과 같게 할 것이다.
    // 위처럼 축약하면 increment 키에 값은 increment 변수에서 참조하는 값을 할당할 수 있다.
    // key가 각각 increment, decrement value가 각각 increment와 decrement가 참조하는 값
}

// const obj = createCoounter();
// obj.increment()
// obj.decrement()

const {increment, decrement} = createCounter();

// 모달 팝업
// 열렸다 꺼졌다 하는 기능을 관리하는 변수를 
```
### 이후에 디자인 패턴
> 디자인 패턴 수업을 들어도 납득을 못함
> 선행되어야하는 부분 객체지향 프로그래밍의 이해도가 생기고 
> class 문법에 익숙해져야함
> 구현 능력이 생겨야함. (구현은 다른영역 구현할수 있다는 것이 객체지향 프로그래밍을 해야만 구현할 수 있는 것은 아니다.)
> 사람들이 많이 사용하는 개발 방법이 디자인 패턴

### 실습 
> 게시판 로컬스토리지 게시판 crud 구현하기
> 번호 제목 내용 작성자 이름

### CRUD 
1. 댓글을 입력할 수 있다.(create)
 - 댓글의 입력폼에 입력을 하고, 버튼을 누르면 글이 입력돼서 저장 
 - 입력창은 초기화 되어야 한다.

2. 댓글의 리스트로 조회해서 출력(read)
 - 댓글의 리스트를 정보를 조회해서 리스트의 형태로 요소를 생성
 - 총 댓글 갯수나 수정 삭제 버튼도 생성
 - 댓글 아이디 날짜 내용 
 - 리스트를 정렬하는 방식 최신순, 과거순, 조회수순

3. 댓글을 수정할 수 있다.(update)
 - 수정하 댓글을 클릭하면 수정에 필요한 내용을 입력하는 입력폼이 생기고
 - 값을 입력하고 확인버튼을 눌러서 정보를 수정

4. 댓글을 삭제(delete)
 - 해당 리스트의 삭제버튼을 누르면 글을 삭제


  create를 작업하면 read와 연관이 깊다.
  데이터가 정상적으로 저장되는지 확인을 하면서 데이터가 정상적으로 추가되는지 
  ud 마지막으로 수정과 삭제를 하면서 read로 확인

### 심화과정 
> 글을 클릭하면 팝업이 뜨고 안에 글의 내용이 보이는 것.
> 페이지 전환 xfd

### 페이지네이션