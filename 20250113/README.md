# 자바스크립트 배열과 함수, 실행 컨텍스트 

## 자바스크립트의 참조 타입
> object, array, Map, Set . .

## 자바스크립트의 메모리 
> call stack 과 heap이라는 메모리 영역이 있고 
> 원시타입은 call stack에 저장이 되어있고
> 참조 타입은 heap 메모리에 저장이된다. 

- 원시타입 : 불변성을 가지고 새로운 데이터가 재할당되면 이전의 주소를 새로운 값의 주소로 변경하고, 이전 주소는 이후에 해제된다.(숫자(Number), 문자열(String), 불리언(Boolean), null, undefined, 심볼(Symbol), BigInt). 값 자제를 변수에 저장한다. 메모리의 특정 공간애 그 값을 저장하며, 이값이 변경되면 새로운 공간을 할당 =
- 참조타입: 주소를 가르키는 주소의 값이 있고 값을 변경할 때 heap 메모리에서 참조되고 있는 주소의 값이 변경된다. 원시타입과 다르게, 변수의 크기가 동적으로 변할 수 있다.

## 배열의 문법 

```js
[예약어] [변수명] =[] ; // 배열을 표현하는 구문 [];
// 객체는 하나의 사물을 표현할 때 
// 배열은 리스트의 형태를 표현할 때, 여러가지 데이터를 나열..

// 다른 언어와 다르게 자바스크립트의 배열은 동적인 타입이 모두 할당될 수 있다. 

const arr = [1, "2", true, undefined, null {}]; // 자바스크립트의 배열의 타입은 정해져있지 않고 동적인 타입을 모두 할당할 수 있다.
// 자바스크립트의 배열은 객체라고 보면 된다.
// 이중배열

const arr = [1,2,3];
// index를 표현할때 0 부터 시작햔다.
// 0 에서부터 숫자를 세어나가면 된다.
// 0 번부터 배열의 안에 들어있는 값의 순서로 인덱스를 참조한다.

// 이전에 배웠던 객체의 형태 
const object = {
    name: "soon"
}
// 객체ㅔ안의 값을 호출할때
object.name === "soon"
object["soon"]

// 배열의 값을 호출할때는 index 번호로 접근한다. 
arr[0] === 1
arr[1] === 2
arr[2] === 3
arr[3] = 4; // 새로운 인덱스에 할당하는 방법 (비추)

// 배열에 값을 추가할때 
// 이미 값을 가지고있는 인덱스에는 재할당을 통해서 해줘도 된다.
// 배열의 맨 뒤나 앞에 값을 추가할때 
// push라는 메서드 사용해서 

arr.push(4); 
// 메서드 함수를 배우지 않아서
// 객체에 포함된 기능들 함수
// 객체안에 포함된 함수는 메서드
// 함수
// 맨 뒤에 4라는 값을 추가한 것

arr === [1,2,3,4];
// 배열의 갯수를 확인하는 키값
arr.length // 배열의 길이를 호출하는 키
arr.length === 4 //4의 길이

for(let i = 1; i<= 100; i++){
    arr,push(i);
}

[1,2,3,4,...,100]

// 컨텐츠를 만드는데 제목이 5개가 필요하다. 숫자의 표현이 들어간다.
for(let i = 1; i<=5; i++){
    arr,push(i + "번째 제목");
}
["1번째 제목","2번째 제목",...,"5번째 제목"]
for(let i = 1; i<=5; i++){
    const object = {
        title : i + "번째 제목",
        content: i + "번째 컨텐츠"
    }
    arr.push(object);
}
[{title : "1번째 제목", content : "1번째 컨텐츠"},...]
// 게시글들의 내용을 배열에 담아서 표현
//배열은 여러가지의 갯수가 많은 데이터를 다룰떄 용이하다.
// 베열은 여러가지의 값을 접근할때 용이하기 때문에 우리가 많은 양의 데이터를 배열에 담아서 사용한다.

arr[2] === { title :"3번째 제목", content : "3번째 컨텐츠"}

// 배열의 갯수만큼 호출하면서 사용해야한다.
// 0~100의 인덱스 접근 0~99
for(let i = 0; i < arr.length i++){
    // dom 요소제어 부분은 나중에
    // 예를 들어서 dom제어를 한다.
    // 새로운 요소를 만들면서 만들어줄 예정 
    // 얘는 걍 예시
    myTag.InnerHTML = arr[i].title + "|" + arr[i].content;
}


```

### '참조 타입의 깊은 복사 얕은 복사' (면접단골)
- 얕은 복사 : 값을 복사하는 방식에서 참조타입의 주소를 복사하는 방식
- 깊은 복사 : 값을 복사하는 방식에서 참조타입의 값을 복사하는 방식

```js
    const a = [1];
    const b = [1];
    console.log(a === b); // 둘의 주소가 다르기 때문에 결과는 false
    // 참조 타입은 주소를 가르키는 주소
    // 값은 heap이라는 공간에 저장이 되고,
    // 주소를 변수가 가르키게된다.
    const c = a;
    // a라는 변수의 주소를 복사해서 사용한 것.
    // 할당된것이 주소
    // 같은 주소를 바라보고 있기 때문에 c에서 가르키는 주소의 값을 변경하면 a의 바라보고 있는 주소의 값이 바뀐다.
    // 얕은 복사가 일어난것.
    
    console.log(c === a);
    C.push(2);
    console.log(a);
    // 깊은 복사
    // 주소가 아닌 값만을 복사해 온 것.

    // 배열을 초기화
    // ...(스프레드 연산자) : 참조타입의 깊은 복사를 하는 구문. 객체 또는 배열의 값을 깊은 복사해온다.
    // 배열이나 객체의 내용을 풀어헤친다. 
    // 값만 복사하는 경우 >> 깊은 복사
    const d = [...a];
    console.log(d===a); //>false

        // 페이지 구현할 때, 검색어를 쳤는데
    // 프론트에서 모든 글의 제어를 다룬다고 가정하고
    // 전체글의 배열을 가지고 있는데
    // 검색어 검색을 했더니 원본배열에서 검색어에 관련된 값만 놔두고 원본 배열을 수정했다.
    // 모든글 탭으로 이동하니 전체글이 보이지 않게되어버림.

    // 요소의 내용을 노드 유사배열
    // 요소의 배열을 복사해서 붙여넣기 하고싶어서 해당 원본요소가 이동되면 안되겠지?

```

// 키 , 메서드, 객체 용어 정리 